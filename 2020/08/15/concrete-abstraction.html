
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Code Smell: Concrete Abstraction</title>
  <meta name="description" content="This is a hand-wavy philosophical article about programming, without quantifiable justification, but with some actionable advice and a case study.">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://matklad.github.io/2020/08/15/concrete-abstraction.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">matklad</a>
      <a href="/about.html">About</a>
      <a href="/resume.html">Resume</a>
      <a href="/links.html">Links</a>
    </nav>
  </header>

  <main>
  <article >

    <h1>
    <a href="#Code-Smell-Concrete-Abstraction">Code Smell: Concrete Abstraction <time datetime="2020-08-15">Aug 15, 2020</time></a>
    </h1>
<p>This is a hand-wavy philosophical article about programming, without quantifiable justification, but with some actionable advice and a case study.</p>
<p>Suppose that there are two types in the program, <code>Blorb</code> and <code>Gonk</code>.
Suppose also that they both can <code>blag</code>.</p>
<p>Does it make sense to add the following trait?</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">trait</span> <span class="hl-title class_">Blag</span> {</code>
<code>    <span class="hl-keyword">fn</span> <span class="hl-title function_">blag</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>);</code>
<code>}</code></pre>

</figure>
<p>I claim that it makes sense only if you have a function like</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">blagyify</span>&lt;T: Blag&gt;(x: T) {</code>
<code>    ...</code>
<code>}</code></pre>

</figure>
<p>That is, if some part of you program is generic over <code>T: Blag</code>.</p>
<p>If in every <code>x.blag()</code> the <code>x</code> is either <code>Blorg</code>, or <code>Gonk</code>, but never a <code>T</code> (each usage is <em>concrete</em>), you don&rsquo;t need this abstraction.
&ldquo;Need&rdquo; is used in a literal sense here: replace a trait with two inherent methods named <code>blag</code>, and the code will be essentially the same.
Using a trait here doesn&rsquo;t achieve any <a href="https://caseymuratori.com/blog_0015">semantic compression</a>.</p>
<p>Given that abstractions have costs &ldquo;don&rsquo;t need&rdquo; can be strengthen to &ldquo;probably shouldn&rsquo;t&rdquo;.</p>

<aside class="block">
<div class="title">What Is The Cost of Abstraction?</div>
<p><em>First</em> is the cognitive cost &mdash; generics (and abstractions in general) are often harder to understand than concretions.
I think this is true regardless of the abstraction <em>skill</em>.
I am skilled with  math which is incomparably more complicated than the typical code; still, I find concrete code easier to understand.
There are exceptions here (you can do less things with <code>T: Default</code> than with <code>Blorb</code>), but they seem to be exceptions rather than a common case.</p>
<p><em>Second</em>, in the context of Rust, is the compile time cost.
It is important to understand <em>why</em> it is the case.
&ldquo;Traits are more complicated for compiler to understand&rdquo; would be a wrong reason.
Rust uses monomorphization to compile generic code.
An <code>fn foo&lt;T&gt;</code> is compiled afresh for each different <code>T</code>, <em>per crate</em>.
If <code>foo&lt;T&gt;</code> is defined in crate <code>a</code>, and <code>foo::&lt;i32&gt;</code> is called in crates <code>b</code> and <code>c</code>, then <code>rustc</code> compiles the same code twice.</p>
<p><em>Third</em>, it often is just more code to write and read.
Consider the original <code>Blag</code> example.
For non-abstract case, there are two inherent impls with <code>blag</code> function.
For abstract case there are these same two impls, plus a trait definition, <em>plus</em> a <code>use Blag</code> on every call-site.</p>

</aside>
  <p>Not going for an abstraction often allows a for more specific interface.
A monad in Haskell is a thing with <code>&gt;&gt;=</code>.
Which isn&rsquo;t telling much.
Languages like Rust and OCaml can&rsquo;t express a general monad, but they still have concrete monads.
The <code>&gt;&gt;=</code> is called <code>and_then</code> for futures and <code>flat_map</code> for lists.
These names are <em>more specific</em> than <code>&gt;&gt;=</code> and are easier to understand.
The <code>&gt;&gt;=</code> is only required if you want to write code generic over type of monad itself, which happens rarely.</p>
<p>Another example of abstraction which is used mostly concretely are collection hierarchies.
In Java or Scala, there&rsquo;s a whole type hierarchy for things which can hold other things.
Rust&rsquo;s type system can&rsquo;t express <code>Collection</code> trait, so we have to get by with using <code>Vec</code>, <code>HashSet</code> and <code>BTreeSet</code> directly.
And it isn&rsquo;t actually a problem in practice.
Turns out, writing code which is generic over collections (and not just over iterators) is not that useful.
The &ldquo;but I can change the collection type later&rdquo; argument also seems overrated &mdash; often, there&rsquo;s only single collection type that makes sense.
Moreover, swapping <code>HashSet</code> for <code>BTreeSet</code> is mostly just a change at the definition site, as the two happen to have almost identical interface anyway.
The only case where I miss Java collections is when I return <code>Vec&lt;T&gt;</code>, but mean a generic <em>unordered</em> collection.
In Java, the difference is captured by <code>List&lt;T&gt;</code> vs <code>Collection&lt;T&gt;</code>.
In Rust, there&rsquo;s nothing built-in for this.
It is possible to define a <code>VecSet&lt;T&gt;(Vec&lt;T&gt;)</code>, but doesn&rsquo;t seem worth the effort.</p>
<p>Collections also suffer from <code>&gt;&gt;=</code> problem &mdash; collapsing similar synonyms under a single name.
Java&rsquo;s
<a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">Queue</a>
has <code>add</code>, <code>offer</code>, <code>remove</code>, and <code>poll</code> methods, because it needs to be a collection, but also is a special kind of collection.
In C++, you have to spell <code>push_back</code> for <code>vector</code>&rsquo;s push operation, so that it duck-types with <code>deque</code>&rsquo;s <code>front</code> and <code>back</code>.</p>

<aside class="admn note">
<i class="fa fa-info-circle"></i>
<div><p>Collection hierarchy is a sufficient, but not necessary condition for mixing up method names.
Rust&rsquo;s <code>BinaryHeap</code> should have had <code>BinaryHeap::pop_max</code> method.
Alas, we are stuck with <code>pop</code>, which, coupled with the fact that the heap is surprisingly and uselessly a max-heap, means many student-hours wasted on debugging misbehaving Dijkstra algorithm.</p>
</div>
</aside><p>Finally, the promised case study!
rust-analyzer needs to convert a bunch of internal type to types suitable for converting them into JSON message of the Language Server Protocol.
<code>ra::Completion</code> is converted into <code>lsp::Completion</code>; <code>ra::Completion</code> contains <code>ra::TextRange</code> which is converted to <code>lsp::Range</code>, etc.</p>
<p>The first implementation started with an abstraction for conversion:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">pub</span> <span class="hl-keyword">trait</span> <span class="hl-title class_">Conv</span> {</code>
<code>    <span class="hl-keyword">type</span> <span class="hl-title class_">Output</span>;</code>
<code>    <span class="hl-keyword">fn</span> <span class="hl-title function_">conv</span>(<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-keyword">Self</span>::Output;</code>
<code>}</code></pre>

</figure>
<p>This abstraction doesn&rsquo;t work for all cases &mdash; sometimes the conversion requires additional context.
For example, to convert a rust-analyzer&rsquo;s offset (a position of byte in the file) to an LSP position (<code>(line, column)</code> pair), a table with positions of newlines is needed.
This is easy to handle:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">pub</span> <span class="hl-keyword">trait</span> <span class="hl-title class_">ConvWith</span>&lt;CTX&gt; {</code>
<code>    <span class="hl-keyword">type</span> <span class="hl-title class_">Output</span>;</code>
<code>    <span class="hl-keyword">fn</span> <span class="hl-title function_">conv_with</span>(<span class="hl-keyword">self</span>, ctx: CTX) <span class="hl-punctuation">-&gt;</span> <span class="hl-keyword">Self</span>::Output;</code>
<code>}</code></pre>

</figure>
<p>Naturally, there was an intricate web of delegating impls.
The typical one looked like this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">impl</span> <span class="hl-title class_">ConvWith</span>&lt;&amp;LineIndex&gt; <span class="hl-keyword">for</span> <span class="hl-title class_">TextRange</span> {</code>
<code>    <span class="hl-keyword">type</span> <span class="hl-title class_">Output</span> = Range;</code>
<code>    <span class="hl-keyword">fn</span> <span class="hl-title function_">conv_with</span>(</code>
<code>        <span class="hl-keyword">self</span>,</code>
<code>        line_index: &amp;LineIndex,</code>
<code>    ) <span class="hl-punctuation">-&gt;</span> lsp_types::Range {</code>
<code>        Range::<span class="hl-title function_ invoke__">new</span>(</code>
<code>            <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">start</span>().<span class="hl-title function_ invoke__">conv_with</span>(line_index),</code>
<code>            <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">end</span>().<span class="hl-title function_ invoke__">conv_with</span>(line_index),</code>
<code>        )</code>
<code>    }</code>
<code>}</code></pre>

</figure>
<p>There were a couple of genuinely generic impls for converting iterators of convertible things.</p>
<p>The code was hard to understand.
It also was hard to use: if calling <code>.conv</code> didn&rsquo;t work immediately, it took a lot of time to find which specific impl didn&rsquo;t apply.
Finally, there were many accidental (as in &ldquo;accidental complexity&rdquo;) changes to the shape of code: <code>CTX</code> being passed by value or by reference, switching between generic parameters and associated types, etc.</p>
<p>I was really annoyed by how this conceptually simple pure boilerplate operation got expressed as clever and fancy abstraction.
Crucially, almost all of the usages of the abstraction (besides those couple of iterator impls) were concrete.
So I replaced the whole edifice with much simpler code, a bunch of functions:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">range</span>(</code>
<code>    line_index: &amp;LineIndex,</code>
<code>    range: TextRange,</code>
<code>) <span class="hl-punctuation">-&gt;</span> lsp_types::Range {</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">start</span> = <span class="hl-title function_ invoke__">position</span>(line_index, range.<span class="hl-title function_ invoke__">start</span>());</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">end</span> = <span class="hl-title function_ invoke__">position</span>(line_index, range.<span class="hl-title function_ invoke__">end</span>());</code>
<code>    lsp_types::Range::<span class="hl-title function_ invoke__">new</span>(start, end)</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">fn</span> <span class="hl-title function_">position</span>(</code>
<code>    line_index: &amp;LineIndex,</code>
<code>    offset: TextSize,</code>
<code>) <span class="hl-punctuation">-&gt;</span> lsp_types::Position {</code>
<code>    ...</code>
<code>}</code></pre>

</figure>
<p>Simplicity and ease of use went up tremendously.
Now instead of typing <code>x.conv()</code> and trying to figure out why an impl I think should apply doesn&rsquo;t apply, I just auto-complete <code>to_proto::range</code> and let the compiler tell me exactly which types don&rsquo;t line up.</p>
<p>I&rsquo;ve lost fancy iterator impls, but the
<a href="https://github.com/rust-analyzer/rust-analyzer/pull/4418/commits/1586bab0b97bef411e6187dfc389557edbc5a16e">total diff</a>
for the commit was <code>+999,-1123</code>.
There was some genuine code re-use in those impls, but it was not justified by the overall compression, even disregarding additional complexity tax.</p>
<p>To sum up, &ldquo;is this abstraction used exclusively concretely?&rdquo; is a meaningful question about the overall shape of code.
If the answer is &ldquo;Yes!&rdquo;, then the abstraction can be replaced by a number of equivalent non-abstract implementations.
As the latter tend to be simpler, shorter, and more direct, &ldquo;Concrete Abstraction&rdquo; can be considered a code smell.
As usual though, any abstract programming advice can be applied only in a concrete context &mdash; don&rsquo;t blindly replace abstractions with concretions, check if provided justifications work for your particular case!</p>
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/iaic5w/blog_post_code_smell_concrete_abstraction/">/r/rust</a>.</p>
</article>
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/src/posts/2020-08-15-concrete-abstraction.dj">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href="/feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
