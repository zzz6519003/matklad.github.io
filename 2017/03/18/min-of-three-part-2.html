
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Min of Three Part 2</title>
  <meta name="description" content="This is the continuation of the previous post about optimizing 2D grid
based dynamic programming algorithm for CPU level parallelism.">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://matklad.github.io/2017/03/18/min-of-three-part-2.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">matklad</a>
      <a href="/about.html">About</a>
      <a href="/resume.html">Resume</a>
      <a href="/links.html">Links</a>
    </nav>
  </header>

  <main>
  <article >

    <h1>
    <a href="#Min-of-Three-Part-2">Min of Three Part 2 <time datetime="2017-03-18">Mar 18, 2017</time></a>
    </h1>
<p>This is the continuation of the <a href="https://matklad.github.io/2017/03/12/min-of-three.html">previous post</a> about optimizing 2D grid
based dynamic programming algorithm for <a href="https://en.wikipedia.org/wiki/Superscalar_processor">CPU level parallelism</a>.</p>
<section id="In-The-Previous-Episode">

    <h2>
    <a href="#In-The-Previous-Episode">In The Previous Episode </a>
    </h2>
<p>This is the code we are trying to make faster:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">dtw</span>(xs: &amp;[<span class="hl-type">f64</span>], ys: &amp;[<span class="hl-type">f64</span>]) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">f64</span> {</code>
<code>    <span class="hl-comment">// assume equal lengths for simplicity</span></code>
<code>    <span class="hl-built_in">assert_eq!</span>(xs.<span class="hl-title function_ invoke__">len</span>(), ys.<span class="hl-title function_ invoke__">len</span>());</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">n</span> = xs.<span class="hl-title function_ invoke__">len</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">prev</span> = <span class="hl-built_in">vec!</span>[<span class="hl-number">0f64</span>; n + <span class="hl-number">1</span>];</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">curr</span> = <span class="hl-built_in">vec!</span>[std::<span class="hl-type">f64</span>::MAX; n + <span class="hl-number">1</span>];</code>
<code>    curr[<span class="hl-number">0</span>] = <span class="hl-number">0.0</span>;</code>
<code></code>
<code>    <span class="hl-keyword">for</span> <span class="hl-variable">ix</span> <span class="hl-keyword">in</span> <span class="hl-number">1</span>..(n + <span class="hl-number">1</span>) {</code>
<code>        ::std::mem::<span class="hl-title function_ invoke__">swap</span>(&amp;<span class="hl-keyword">mut</span> curr, &amp;<span class="hl-keyword">mut</span> prev);</code>
<code>        curr[<span class="hl-number">0</span>] = std::<span class="hl-type">f64</span>::MAX;</code>
<code>        <span class="hl-keyword">for</span> <span class="hl-variable">iy</span> <span class="hl-keyword">in</span> <span class="hl-number">1</span>..(n + <span class="hl-number">1</span>) {</code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">d11</span> = prev[iy - <span class="hl-number">1</span>];</code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">d01</span> = curr[iy - <span class="hl-number">1</span>];</code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">d10</span> = prev[iy];</code>
<code></code>
<code>            <span class="hl-comment">// Find the minimum of d11, d01, d10</span></code>
<code>            <span class="hl-comment">// by enumerating all the cases.</span></code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">d</span> = <span class="hl-keyword">if</span> d11 &lt; d01 {</code>
<code>                <span class="hl-keyword">if</span> d11 &lt; d10 { d11 } <span class="hl-keyword">else</span> { d10 }</code>
<code>            } <span class="hl-keyword">else</span> {</code>
<code>                <span class="hl-keyword">if</span> d01 &lt; d10 { d01 } <span class="hl-keyword">else</span> { d10 }</code>
<code>            };</code>
<code></code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">cost</span> = {</code>
<code>                <span class="hl-keyword">let</span> <span class="hl-variable">t</span> = xs[ix - <span class="hl-number">1</span>] - ys[iy - <span class="hl-number">1</span>];</code>
<code>                t * t</code>
<code>            };</code>
<code></code>
<code>            curr[iy] = d + cost;</code>
<code>        }</code>
<code>    }</code>
<code>    curr[n]</code>
<code>}</code></pre>

</figure>
<p><a href="http://play.rust-lang.org/?gist=3d42c67904441279c4cbb1708fb35a06&amp;version=stable">Code on Rust playground</a> (293 ms)</p>
<p>It calculates <a href="https://en.wikipedia.org/wiki/Dynamic_time_warping">dynamic time warping</a> distance between two <code>double</code>
vectors using an update rule which is structured like this:</p>

<figure>

<img alt="Dynamic programming 2D table" src="/assets/min3_table.png">
</figure>
<p>This code takes 293 milliseconds to run on a particular input
data. The speedup from 435 milliseconds stated in the previous post is
due to the Moor&rsquo;s law: I&rsquo;ve upgraded the CPU :)</p>
<p>We can bring run time down by tweaking how we calculate the minimum of
three elements.</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">min2</span>(x: <span class="hl-type">f64</span>, y: <span class="hl-type">f64</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">f64</span> {</code>
<code>    <span class="hl-keyword">if</span> x &lt; y { x } <span class="hl-keyword">else</span> { y }</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">fn</span> <span class="hl-title function_">dtw</span>(xs: &amp;[<span class="hl-type">f64</span>], ys: &amp;[<span class="hl-type">f64</span>]) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">f64</span> {</code>
<code>    <span class="hl-comment">// ...</span></code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">d</span> = <span class="hl-title function_ invoke__">min2</span>(<span class="hl-title function_ invoke__">min2</span>(d11, d10), d01);</code>
<code>    <span class="hl-comment">// ...</span></code>
<code>}</code></pre>

</figure>
<p><a href="http://play.rust-lang.org/?gist=caf7609db82341fb7ccf13033738232e&amp;version=stable">Code on Rust playground</a> (210 ms)</p>
<p>This version takes only 210 milliseconds, presumably because the
minimum of two elements in the previous row can be calculated without
waiting for the preceding element in the current row to be computed.</p>
<p>The assembly for the main loop looks like this (AT&amp;T syntax,
destination register on the right)</p>

<figure class="code-block">


<pre><code>   18.32    vmovsd -0x8(%rax,%rsi,8),%xmm1</code>
<code>    0.00    vminsd (%rax,%rsi,8),%xmm1,%xmm1</code>
<code>    6.72    vminsd %xmm0,%xmm1,%xmm0</code>
<code>    4.64    vmovsd -0x8(%r12,%r10,8),%xmm1</code>
<code>    0.00    vsubsd -0x8(%r13,%rsi,8),%xmm1,%xmm1</code>
<code>    7.69    vmulsd %xmm1,%xmm1,%xmm1</code>
<code>   36.14    vaddsd %xmm1,%xmm0,%xmm0</code>
<code>   14.16    vmovsd %xmm0,(%rdi,%rsi,8)</code></pre>

</figure>
<p>Check the <a href="https://matklad.github.io/2017/03/12/min-of-three.html">previous post</a> for more details!</p>
</section>
<section id="The-parallel-plan">

    <h2>
    <a href="#The-parallel-plan">The parallel plan </a>
    </h2>
<p>Can we loosen dependencies between cells even more to benefit from instruction
level parallelism? What if instead of filling the table row by row, we do it
diagonals?</p>

<figure>

<img alt="Diagonal update" src="/assets/min3_diag_color.png">
</figure>
<p>We&rsquo;d need to remember <strong>two</strong> previous diagonals instead of one previous
row, but all the cells on the next diagonal would be independent! In
theory, compiler should be able to use <a href="https://en.wikipedia.org/wiki/SIMD#Hardware">SIMD instructions</a> to make the
computation truly parallel.</p>
</section>
<section id="Implementation-Plan">

    <h2>
    <a href="#Implementation-Plan">Implementation Plan </a>
    </h2>
<p>Coding up this diagonal traversal is a bit tricky, because you need to
map linear vector indices to diagonal indices.</p>
<p>The original indexing worked like this:</p>

<figure class="code-block">


<pre><code>        iy</code>
<code>       ----&gt;</code>
<code>    | . . . .</code>
<code> ix | . . . .</code>
<code>    | . . . .</code>
<code>    V . . . .</code></pre>

</figure>
<ul>
<li>
<code>ix</code> and <code>iy</code> are indices in the input vectors.
</li>
<li>
The outer loop is over <code>ix</code>.
</li>
<li>
On each iteration, we remember two rows (<code>curr</code> and <code>prev</code> in the
code).
</li>
</ul>
<p>For our grand plan, we need to fit a rhombus peg in a square hole:</p>

<figure class="code-block">


<pre><code>   id</code>
<code>  ----&gt;</code>
<code> . . . .        |</code>
<code>   . . . .      | ix</code>
<code>     . . . .    |</code>
<code>       . . . .  V</code></pre>

</figure>
<ul>
<li>
<code>id</code> is the index of the diagonal. There are twice as much diagonals
as rows.
</li>
<li>
The outer loop is over <code>id</code>.
</li>
<li>
On each iteration we remember three columns (<code>d1</code>, <code>d2</code> <code>d3</code> in the
code).
</li>
<li>
There is a phase transition once we&rsquo;ve crossed the main diagonal.
</li>
<li>
We can derive <code>iy</code> from the fact that <code>ix + iy = id</code>.
</li>
</ul>
</section>
<section id="Code">

    <h2>
    <a href="#Code">Code </a>
    </h2>
<p>The actual code looks like this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">dtw</span>(xs: &amp;[<span class="hl-type">f64</span>], ys: &amp;[<span class="hl-type">f64</span>]) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">f64</span> {</code>
<code>    <span class="hl-built_in">assert_eq!</span>(xs.<span class="hl-title function_ invoke__">len</span>(), ys.<span class="hl-title function_ invoke__">len</span>());</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">n</span> = xs.<span class="hl-title function_ invoke__">len</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">d1</span> = <span class="hl-built_in">vec!</span>[<span class="hl-number">0f64</span>; n + <span class="hl-number">1</span>];</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">d2</span> = <span class="hl-built_in">vec!</span>[<span class="hl-number">0f64</span>; n + <span class="hl-number">1</span>];</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">d3</span> = <span class="hl-built_in">vec!</span>[<span class="hl-number">0f64</span>; n + <span class="hl-number">1</span>];</code>
<code>    d2[<span class="hl-number">0</span>] = ::std::<span class="hl-type">f64</span>::MAX;</code>
<code></code>
<code>    <span class="hl-keyword">for</span> <span class="hl-variable">id</span> <span class="hl-keyword">in</span> <span class="hl-number">1</span>..(<span class="hl-number">2</span> * n + <span class="hl-number">1</span>) {</code>
<code>        ::std::mem::<span class="hl-title function_ invoke__">swap</span>(&amp;<span class="hl-keyword">mut</span> d1, &amp;<span class="hl-keyword">mut</span> d2);</code>
<code>        ::std::mem::<span class="hl-title function_ invoke__">swap</span>(&amp;<span class="hl-keyword">mut</span> d2, &amp;<span class="hl-keyword">mut</span> d3);</code>
<code></code>
<code>        <span class="hl-keyword">let</span> <span class="hl-variable">ix_range</span> = <span class="hl-keyword">if</span> id &lt;= n {</code>
<code>            d3[<span class="hl-number">0</span>] = ::std::<span class="hl-type">f64</span>::MAX;</code>
<code>            d3[id] = ::std::<span class="hl-type">f64</span>::MAX;</code>
<code>            <span class="hl-number">1</span>..id</code>
<code>        } <span class="hl-keyword">else</span> {</code>
<code>            (id - n..n + <span class="hl-number">1</span>)</code>
<code>        };</code>
<code></code>
<code>        <span class="hl-keyword">for</span> <span class="hl-variable">ix</span> <span class="hl-keyword">in</span> ix_range {</code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">iy</span> = id - ix;</code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">d</span> = <span class="hl-title function_ invoke__">min2</span>(<span class="hl-title function_ invoke__">min2</span>(d2[ix - <span class="hl-number">1</span>], d2[ix]), d1[ix - <span class="hl-number">1</span>]);</code>
<code>            <span class="hl-keyword">let</span> <span class="hl-variable">cost</span> = {</code>
<code>                <span class="hl-keyword">let</span> <span class="hl-variable">t</span> = xs[ix - <span class="hl-number">1</span>] - ys[iy - <span class="hl-number">1</span>];</code>
<code>                t * t</code>
<code>            };</code>
<code>            d3[ix] = d + cost;</code>
<code>        };</code>
<code>    }</code>
<code></code>
<code>    d3[n]</code>
<code>}</code></pre>

</figure>
<p><a href="http://play.rust-lang.org/?gist=4522cb9d4d0e95e9daa4b1f1d6a563b0&amp;version=stable">Code on Rust playground</a> (185 ms)</p>
<p>It take 185 milliseconds to run. The assembly for the main loop is
quite interesting:</p>

<figure class="code-block">


<pre><code>    1.67    cmp    %rax,%rdx</code>
<code>    0.00    jbe    6d95</code>
<code>    1.95    lea    0x1(%rax),%rbx</code>
<code>    8.09    cmp    %rbx,%rdx</code>
<code>    0.98    jbe    6da4</code>
<code>    1.12    cmp    %rax,%r8</code>
<code>    0.00    jbe    6db3</code>
<code>    3.49    cmp    %r12,%rax</code>
<code>    0.00    jae    6de9</code>
<code>    9.07    cmp    %r12,%rcx</code>
<code>    0.00    jae    6dc5</code>
<code>    0.56    cmp    %rbx,%r9</code>
<code>    0.00    jbe    6dd7</code>
<code>    2.23    vmovsd (%r15,%rax,8),%xmm0</code>
<code>   11.72    vminsd 0x8(%r15,%rax,8),%xmm0,%xmm0</code>
<code>    2.09    vminsd (%r11,%rax,8),%xmm0,%xmm0</code>
<code>    2.51    vmovsd (%r14,%rax,8),%xmm1</code>
<code>    7.95    mov    -0x88(%rbp),%rdi</code>
<code>    3.07    vsubsd (%rdi,%rcx,8),%xmm1,%xmm1</code>
<code>    3.91    vmulsd %xmm1,%xmm1,%xmm1</code>
<code>   15.90    vaddsd %xmm1,%xmm0,%xmm0</code>
<code>    8.37    vmovsd %xmm0,0x8(%r13,%rax,8)</code></pre>

</figure>
<p>First of all, we don&rsquo;t see any vectorized instructions, the code does
roughly the same operations as the in previous version. Also, there is
a whole bunch of extra branching instructions on the top. These are
bounds checks which were not eliminated this time. And this is great:
if I add all off-by one errors I&rsquo;ve made implementing diagonal
indexing, I would get an integer overflow! Nevertheless, we&rsquo;ve got
some speedup.</p>
<p>Can we go further and add get SIMD instructions here? At the moment,
Rust does not have a stable way to explicitly emit SIMD
(<a href="https://internals.rust-lang.org/t/getting-explicit-simd-on-stable-rust/4380">it&rsquo;s going to change some day</a>) (UPDATE: we have <a href="https://doc.rust-lang.org/core/arch/index.html">SIMD on stable</a> now!), so the only choice we
have is to tweak the source code until LLVM sees an opportunity for
vectorization.</p>
</section>
<section id="SIMD">

    <h2>
    <a href="#SIMD">SIMD </a>
    </h2>
<p>Although bounds checks themselves don&rsquo;t slow down the code that much,
they can prevent LLVM from vectorizing. So let&rsquo;s dip our toes into
<code>unsafe</code>:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">unsafe</span> {</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">d</span> = <span class="hl-title function_ invoke__">min2</span>(</code>
<code>        <span class="hl-title function_ invoke__">min2</span>(*d2.<span class="hl-title function_ invoke__">get_unchecked</span>(ix - <span class="hl-number">1</span>), *d2.<span class="hl-title function_ invoke__">get_unchecked</span>(ix)),</code>
<code>        *d1.<span class="hl-title function_ invoke__">get_unchecked</span>(ix - <span class="hl-number">1</span>),</code>
<code>    );</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">cost</span> = {</code>
<code>        <span class="hl-keyword">let</span> <span class="hl-variable">t</span> =</code>
<code>            xs.<span class="hl-title function_ invoke__">get_unchecked</span>(ix - <span class="hl-number">1</span>) - ys.<span class="hl-title function_ invoke__">get_unchecked</span>(iy - <span class="hl-number">1</span>);</code>
<code>        t * t</code>
<code>    };</code>
<code>    *d3.<span class="hl-title function_ invoke__">get_unchecked_mut</span>(ix) = d + cost;</code>
<code>}</code></pre>

</figure>
<p><a href="http://play.rust-lang.org/?gist=a7d7e447794eda6fef7b08a28c2c79da&amp;version=stable">Code on Rust playground</a> (52 ms)</p>
<p>The  code is  as  fast as  it  is  ugly: it  finishes  in whooping  52
milliseconds! And of course we see SIMD in the assembly:</p>

<figure class="code-block">


<pre><code>    5.74    vmovupd -0x8(%r8,%rcx,8),%ymm0</code>
<code>    1.44    vminpd (%r8,%rcx,8),%ymm0,%ymm0</code>
<code>    7.66    vminpd -0x8(%r11,%rcx,8),%ymm0,%ymm0</code>
<code>    5.26    vmovupd -0x8(%rbx,%rcx,8),%ymm1</code>
<code>    7.66    vpermpd $0x1b,0x20(%r12),%ymm2</code>
<code>    5.26    vsubpd %ymm2,%ymm1,%ymm1</code>
<code>    7.66    vmulpd %ymm1,%ymm1,%ymm1</code>
<code>    8.61    vaddpd %ymm1,%ymm0,%ymm0</code>
<code>    2.39    vmovupd %ymm0,(%rdx,%rcx,8)</code>
<code>    2.39    vmovupd 0x18(%r8,%rcx,8),%ymm0</code>
<code>    5.74    vminpd 0x20(%r8,%rcx,8),%ymm0,%ymm0</code>
<code>    9.09    vminpd 0x18(%r11,%rcx,8),%ymm0,%ymm0</code>
<code>    0.96    vmovupd 0x18(%rbx,%rcx,8),%ymm1</code>
<code>    4.78    vpermpd $0x1b,(%r12),%ymm2</code>
<code>    3.83    vsubpd %ymm2,%ymm1,%ymm1</code>
<code>    3.83    vmulpd %ymm1,%ymm1,%ymm1</code>
<code>   10.53    vaddpd %ymm1,%ymm0,%ymm0</code>
<code>    4.78    vmovupd %ymm0,0x20(%rdx,%rcx,8)</code></pre>

</figure>
</section>
<section id="Safe-SIMD">

    <h2>
    <a href="#Safe-SIMD">Safe SIMD </a>
    </h2>
<p>How can we get the same results with safe Rust? One possible way is to
use iterators, but in this case the resulting code would be rather
ugly, because you&rsquo;ll need a lot of nested <code>.zip</code>&rsquo;s. So let&rsquo;s try a
simple trick of hoisting the bounds checks of the loop. The idea is to
transform this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">for</span> <span class="hl-variable">i</span> <span class="hl-keyword">in</span> <span class="hl-number">0</span>..n {</code>
<code>    assert i &lt; xs.<span class="hl-title function_ invoke__">len</span>();</code>
<code>    xs.<span class="hl-title function_ invoke__">get_unchecked</span>(i);</code>
<code>}</code></pre>

</figure>
<p>into this:</p>

<figure class="code-block">


<pre><code>assert xs.<span class="hl-title function_ invoke__">len</span>() &lt; n;</code>
<code><span class="hl-keyword">for</span> <span class="hl-variable">i</span> <span class="hl-keyword">in</span> <span class="hl-number">0</span>..n {</code>
<code>    xs.<span class="hl-title function_ invoke__">get_unchecked</span>(i);</code>
<code>}</code></pre>

</figure>
<p>In Rust, this is possible by explicitly slicing the buffer before the loop:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">let</span> <span class="hl-variable">ix_range</span> = <span class="hl-keyword">if</span> id &lt;= n {</code>
<code>    d3[<span class="hl-number">0</span>] = ::std::<span class="hl-type">f64</span>::MAX;</code>
<code>    d3[id] = ::std::<span class="hl-type">f64</span>::MAX;</code>
<code>    <span class="hl-number">1</span>..id</code>
<code>} <span class="hl-keyword">else</span> {</code>
<code>    (id - n..n + <span class="hl-number">1</span>)</code>
<code>};</code>
<code></code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">ix_range_1</span> = ix_range.start - <span class="hl-number">1</span>..ix_range.end - <span class="hl-number">1</span>;</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">dn</span> = ix_range.end - ix_range.start;</code>
<code></code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">d1</span> = &amp;d1[ix_range_1.<span class="hl-title function_ invoke__">clone</span>()];</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">d2_0</span> = &amp;d2[ix_range.<span class="hl-title function_ invoke__">clone</span>()];</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">d2_1</span> = &amp;d2[ix_range_1.<span class="hl-title function_ invoke__">clone</span>()];</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">d3</span> = &amp;<span class="hl-keyword">mut</span> d3[ix_range.<span class="hl-title function_ invoke__">clone</span>()];</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">xs</span> = &amp;xs[ix_range_1.<span class="hl-title function_ invoke__">clone</span>()];</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">ys</span> = &amp;ys[id - ix_range.end..id - ix_range.start];</code>
<code></code>
<code><span class="hl-comment">// All the buffers we access inside the loop</span></code>
<code><span class="hl-comment">// will have the same length</span></code>
<code><span class="hl-built_in">assert!</span>(</code>
<code>    d1.<span class="hl-title function_ invoke__">len</span>() == dn &amp;&amp; d2_0.<span class="hl-title function_ invoke__">len</span>() == dn &amp;&amp; d2_1.<span class="hl-title function_ invoke__">len</span>() == dn</code>
<code>    &amp;&amp; d3.<span class="hl-title function_ invoke__">len</span>() == dn &amp;&amp; xs.<span class="hl-title function_ invoke__">len</span>() == dn &amp;&amp; ys.<span class="hl-title function_ invoke__">len</span>() == dn</code>
<code>);</code>
<code></code>
<code><span class="hl-keyword">for</span> <span class="hl-variable">i</span> <span class="hl-keyword">in</span> <span class="hl-number">0</span>..dn { <span class="hl-comment">// so hopefully LLVM can eliminate bounds checks.</span></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">d</span> = <span class="hl-title function_ invoke__">min2</span>(<span class="hl-title function_ invoke__">min2</span>(d2_0[i], d2_1[i]), d1[i]);</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">cost</span> = {</code>
<code>        <span class="hl-keyword">let</span> <span class="hl-variable">t</span> = xs[i] - ys[ys.<span class="hl-title function_ invoke__">len</span>() - i - <span class="hl-number">1</span>];</code>
<code>        t * t</code>
<code>    };</code>
<code>    d3[i] = d + cost;</code>
<code>};</code></pre>

</figure>
<p><a href="http://play.rust-lang.org/?gist=65a707923aa0d49aa06e84c509c83bed&amp;version=stable">Code on Rust playground</a> (107 ms)</p>
<p>This is definitely an improvement over the best safe version, but is
still twice as slow as the unsafe variant. Looks like some bounds
checks are still there! It is possible to find them by selectively
using <code>unsafe</code> to replace some indexing operations.</p>
<p>And it turns out that only <code>ys</code> is still checked!</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">let</span> <span class="hl-variable">t</span> = xs[i] - <span class="hl-keyword">unsafe</span> { ys.<span class="hl-title function_ invoke__">get_unchecked</span>(ys.<span class="hl-title function_ invoke__">len</span>() - i - <span class="hl-number">1</span>) };</code></pre>

</figure>
<p><a href="http://play.rust-lang.org/?gist=d735daf2993acd1286d399c813546c71&amp;version=stable">Code on Rust playground</a> (52 ms)</p>
<p>If we use <code>unsafe</code> only for <code>ys</code>, we regain all the performance.</p>
<p>LLVM is having trouble iterating <code>ys</code> in reverse, but the fix is easy:
just reverse it once at the beginning of the function:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">let</span> <span class="hl-variable">ys_rev</span>: <span class="hl-type">Vec</span>&lt;<span class="hl-type">f64</span>&gt; = ys.<span class="hl-title function_ invoke__">iter</span>().<span class="hl-title function_ invoke__">cloned</span>().<span class="hl-title function_ invoke__">rev</span>().<span class="hl-title function_ invoke__">collect</span>();</code></pre>

</figure>
<p><a href="http://play.rust-lang.org/?gist=6f6bcf941df819d10f8fa688f86765ad&amp;version=stable">Code on Rust playground</a> (50 ms)</p>
</section>
<section id="Conclusions">

    <h2>
    <a href="#Conclusions">Conclusions </a>
    </h2>
<p>We&rsquo;ve gone from almost 300 milliseconds to only 50 in safe Rust. That
is quite impressive! However, the resulting code is rather brittle and
even small changes can prevent vectorization from triggering.</p>
<p>It&rsquo;s also important to understand that to allow for SIMD, we had to
change the underlying algorithm. This is not something even a very
smart compiler could do!</p>
</section>
</article>
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/src/posts/2017-03-18-min-of-three-part-2.dj">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href="/feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
