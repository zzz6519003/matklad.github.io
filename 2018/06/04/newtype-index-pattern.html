
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Newtype Index Pattern</title>
  <meta name="description" content="Similarly to the previous post, we will once again add types to the Rust
code which works perfectly fine without them. This time, we'll try to improve
the pervasive pattern of using indexes to manage cyclic data structures.">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://matklad.github.io/2018/06/04/newtype-index-pattern.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">matklad</a>
      <a href="/about.html">About</a>
      <a href="/resume.html">Resume</a>
      <a href="/links.html">Links</a>
    </nav>
  </header>

  <main>
  <article >

    <h1>
    <a href="#Newtype-Index-Pattern">Newtype Index Pattern <time datetime="2018-06-04">Jun 4, 2018</time></a>
    </h1>
<p>Similarly to the <a href="/2018/05/24/typed-key-pattern.html">previous post</a>, we will once again add types to the Rust
code which works perfectly fine without them. This time, we&rsquo;ll try to improve
the pervasive pattern of using indexes to manage cyclic data structures.</p>
<section id="The-problem">

    <h2>
    <a href="#The-problem">The problem </a>
    </h2>
<p>Often one wants to work with a data structure which contains a cycle
of some form: object <code>foo</code> references <code>bar</code>, which references <code>baz</code>
which references <code>foo</code> again. The textbook example here is a graph of
vertices and edges. In practice, however, true graphs are a rare
encounter. Instead, you are more likely to see a tree with parent
pointers, which contains a lot of trivial cycles. And sometimes cyclic
graphs are implicit: an <code>Employee</code> can be the head of a <code>Departement</code>,
and <code>Departement</code> has a <code>Vec&lt;Employee&gt;</code> personal. This is sort-of a
graph in disguise: in usual graphs, all vertices are of the same type,
and here <code>Employee</code> and <code>Departement</code> are different types.</p>
<p>Working with such data structures is hard in any language. To arrive
at a situation when <code>A</code> points to <code>B</code> which points back to <code>A</code>, some
form of mutability is required. Indeed, either <code>A</code> or <code>B</code> must be
created first, and so it can not point to the other immediately after
construction. You can paper over this mutability with <code>let rec</code>, as in
OCaml, or with laziness, as in Haskell, but it is still there.</p>
<p>Rust tends to surface subtle problems in the form of compile-time
errors, so implementing such graphs in Rust is challenging. The three
usual approaches are:</p>
<ul>
<li>
reference counting, explanation by <a href="https://github.com/nrc/r4cppp/blob/master/graphs/README.md#rcrefcellnode">nrc</a>,
</li>
<li>
arena and real cyclic references, explanation by
<a href="https://exyr.org/2018/rust-arenas-vs-dropck/">simonsapin</a> (this one is really neat!),
</li>
<li>
arena and integer indices, explanation by <a href="http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">nikomatsakis</a>.
</li>
</ul>
<p>(apparently, rewriting a Haskell monad tutorial in Rust results in a
graphs blog post).</p>
<p>I personally like the indexing approach the most. However it presents
an interesting readability challenge. With references, you have a
<code>foo</code> of type <code>&amp;Foo</code>, and it is immediately clear what that <code>foo</code> is,
and what you can do with it. With indexes, however, you have a <code>foo:
usize</code>, and it is not obvious that you somehow can get a <code>Foo</code>. Even
worse, if indexes are used for two types of objects, like <code>Foo</code> and
<code>Bar</code>, you may end up with <code>thing: usize</code>. While writing the code with
<code>usize</code> actually works pretty well (I don&rsquo;t think I&rsquo;ve ever used the
wrong index type), reading it later is more complicated, because
<code>usize</code> is much less suggestive of what you could do.</p>
</section>
<section id="Newtype-trick">

    <h2>
    <a href="#Newtype-trick">Newtype trick </a>
    </h2>
<p>One way to ameliorate this problem is to introduce a newtype wrapper
around <code>usize</code>:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">Foo</span>;</code>
<code></code>
<code><span class="hl-meta">#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]</span></code>
<code><span class="hl-keyword">struct</span> <span class="hl-title class_">FooIdx</span>(<span class="hl-type">usize</span>);</code>
<code></code>
<code><span class="hl-keyword">struct</span> <span class="hl-title class_">Arena</span> {</code>
<code>    foos: <span class="hl-type">Vec</span>&lt;Foo&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">Arena</span> {</code>
<code>    <span class="hl-keyword">fn</span> <span class="hl-title function_">foo</span>(&amp;<span class="hl-keyword">self</span>, foo: FooIdx) <span class="hl-punctuation">-&gt;</span> &amp;Foo {</code>
<code>        &amp;<span class="hl-keyword">self</span>.foos[foo.<span class="hl-number">0</span>]</code>
<code>    }</code>
<code>}</code></pre>

</figure>
<p>Here, &ldquo;one should use <code>FooIdx</code> to index into <code>Vec&lt;Foo&gt;</code>&rdquo; is still just
a convention. A cool thing about Rust is that we can turn this
convention into a property verified during type checking. By adding an
appropriate impl, we should be able to index into <code>Vec&lt;Foo&gt;</code> with
<code>FooIdx</code> directly:</p>

<figure class="code-block">


<pre><code><span class="hl-meta">#[test]</span></code>
<code><span class="hl-keyword">fn</span> <span class="hl-title function_">direct_indexing</span>(foos: <span class="hl-type">Vec</span>&lt;Foo&gt;, idx: FooIdx) {</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">_foo</span>: &amp;Foo = &amp;foos[idx];</code>
<code>}</code></pre>

</figure>
<p>The impl would look like this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">use</span> std::ops;</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">ops</span>::Index&lt;FooIdx&gt; <span class="hl-keyword">for</span> <span class="hl-title class_">Vec</span>&lt;Foo&gt; {</code>
<code>    <span class="hl-keyword">type</span> <span class="hl-title class_">Output</span> = Foo;</code>
<code></code>
<code>    <span class="hl-keyword">fn</span> <span class="hl-title function_">index</span>(&amp;<span class="hl-keyword">self</span>, index: FooIdx) <span class="hl-punctuation">-&gt;</span> &amp;Foo {</code>
<code>        &amp;<span class="hl-keyword">self</span>[index.<span class="hl-number">0</span>]</code>
<code>    }</code>
<code>}</code></pre>

</figure>
</section>
<section id="Coherence">

    <h2>
    <a href="#Coherence">Coherence </a>
    </h2>
<p>It&rsquo;s insightful to study why this impl is allowed. In Rust, types,
traits and impls are separate. This creates a room for a problem: what
if there are two impl blocks for a given (trait, type) pair? The
obvious choice is to forbid to have two impls in the first place, and
this is what Rust does.</p>
<p>Actually enforcing this restriction is tricky! The simplest rule of
&ldquo;error if a set of crates currently compiled contains duplicate impls&rdquo;
has severe drawbacks. First of all, this is a global check, which
requires the knowledge of all compiled crates. This postpones the
check until the later stages of compilation. It also plays awfully
with dependencies, because two completely unrelated crates might fail
the compilation if present simultaneously. What&rsquo;s more, it doesn&rsquo;t
actually solve the problem, because the compiler does not necessary
know the set of all crates beforehand. For example, you may load
additional code at runtime via dynamic libraries, and silent bad
things might happen if you program and dynamic library have duplicate
impls.</p>
<p>To be able to combine crates freely, we want a much stronger property:
not only the set of crates currently compiled, but all existing and
even future crates must not violate the one impl restriction. How on
earth is it possible to check this? Should <code>cargo publish</code> look for
conflicting impls across all of the crates.io?</p>
<p>Luckily, and this is stunningly beautiful, it is possible to loosen
this world-global property to a local one. In the simplest form, we
can place a restriction that <code>impl Foo for Bar</code> can appear either in
the crate that defines <code>Foo</code>, or in the one that defines
<code>Bar</code>. Crucially, whichever one defines the impl has to use the other,
which makes it possible to detect the conflict.</p>
<p>This is all really nifty, but we&rsquo;ve just defined an <code>Index</code> impl for
<code>Vec</code>, and both <code>Index</code> and <code>Vec</code> are from the standard library! How
is it possible? The trick is that <code>Index</code> has a type parameter: <code>trait
Index&lt;Idx: ?Sized&gt;</code>. It is a template for a trait of sorts, and we get
a &ldquo;real&rdquo; trait when we substitute type parameter with a type. Because
<code>FooIdx</code> is a local type, the resulting <code>Index&lt;FromIdx&gt;</code> trait is also
considered local. The precise rules here are quite tricky, <a href="https://github.com/rust-lang/rfcs/pull/2451">this
RFC</a> explains them pretty well.</p>
</section>
<section id="More-impls">

    <h2>
    <a href="#More-impls">More impls </a>
    </h2>
<p>Because <code>Index&lt;FooIdx&gt;</code> and <code>Index&lt;BarIdx&gt;</code> are different traits, one
type can implement both of them. This is convenient for containers
which hold distinct types:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">Arena</span> {</code>
<code>    foos: <span class="hl-type">Vec</span>&lt;Foo&gt;,</code>
<code>    bars: <span class="hl-type">Vec</span>&lt;Bar&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">ops</span>::Index&lt;FooIdx&gt; <span class="hl-keyword">for</span> <span class="hl-title class_">Arena</span> { ... }</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">ops</span>::Index&lt;BarIdx&gt; <span class="hl-keyword">for</span> <span class="hl-title class_">Arena</span> { ... }</code></pre>

</figure>
<p>It&rsquo;s also helpful to define arithmetic operations and conversions for
the newtyped indexes. I&rsquo;ve put together a
<a href="https://crates.io/crates/typed_index_derive"><code>typed_index_derive</code></a> crate to automate this boilerplate via a
proc macro, the end result looks like this:</p>

<figure class="code-block">


<pre><code><span class="hl-meta">#[macro_use]</span></code>
<code><span class="hl-keyword">extern</span> <span class="hl-keyword">crate</span> typed_index_derive;</code>
<code></code>
<code><span class="hl-keyword">struct</span> <span class="hl-title class_">Spam</span>(<span class="hl-type">String</span>);</code>
<code></code>
<code><span class="hl-meta">#[derive(</span></code>
<code><span class="hl-meta">    // Usual derives for plain old data</span></code>
<code><span class="hl-meta">    Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash,</span></code>
<code><span class="hl-meta"></span></code>
<code><span class="hl-meta">    TypedIndex</span></code>
<code><span class="hl-meta">)]</span></code>
<code><span class="hl-meta">#[typed_index(Spam)]</span> <span class="hl-comment">// index into `&amp;[Spam]`</span></code>
<code><span class="hl-keyword">struct</span> <span class="hl-title class_">SpamIdx</span>(<span class="hl-type">usize</span>); <span class="hl-comment">// could be `u32` instead of `usize`</span></code>
<code></code>
<code><span class="hl-keyword">fn</span> <span class="hl-title function_">main</span>() {</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">spams</span> = <span class="hl-built_in">vec!</span>[<span class="hl-title function_ invoke__">Spam</span>(<span class="hl-string">&quot;foo&quot;</span>.<span class="hl-title function_ invoke__">into</span>()), <span class="hl-title function_ invoke__">Spam</span>(<span class="hl-string">&quot;bar&quot;</span>.<span class="hl-title function_ invoke__">into</span>()), <span class="hl-title function_ invoke__">Spam</span>(<span class="hl-string">&quot;baz&quot;</span>.<span class="hl-title function_ invoke__">into</span>())];</code>
<code></code>
<code>    <span class="hl-comment">// Conversions between `usize` and `SpamIdx`</span></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">idx</span>: SpamIdx = <span class="hl-number">1</span>.<span class="hl-title function_ invoke__">into</span>();</code>
<code>    <span class="hl-built_in">assert_eq!</span>(<span class="hl-type">usize</span>::<span class="hl-title function_ invoke__">from</span>(idx), <span class="hl-number">1</span>);</code>
<code></code>
<code>    <span class="hl-comment">// Indexing `Vec&lt;Spam&gt;` with `SpamIdx`, `IndexMut` works as well</span></code>
<code>    <span class="hl-built_in">assert_eq!</span>(&amp;spams[idx].<span class="hl-number">0</span>, <span class="hl-string">&quot;bar&quot;</span>);</code>
<code></code>
<code>    <span class="hl-comment">// Indexing `Vec&lt;usize&gt;` is rightfully forbidden</span></code>
<code>    <span class="hl-comment">// vec![1, 2, 3][idx]</span></code>
<code>    <span class="hl-comment">// error: slice indices are of type `usize` or ranges of `usize`</span></code>
<code></code>
<code>    <span class="hl-comment">// It is possible to  add/subtract `usize` from an index</span></code>
<code>    <span class="hl-built_in">assert_eq!</span>(&amp;spams[idx - <span class="hl-number">1</span>].<span class="hl-number">0</span>, <span class="hl-string">&quot;foo&quot;</span>);</code>
<code></code>
<code>    <span class="hl-comment">// The difference between two indices is `usize`</span></code>
<code>    <span class="hl-built_in">assert_eq!</span>(idx - idx, <span class="hl-number">0usize</span>);</code>
<code>}</code></pre>

</figure>
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/8ohaj4/blog_post_newtype_index_pattern/">/r/rust</a>.</p>
</section>
</article>
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/src/posts/2018-06-04-newtype-index-pattern.dj">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href="/feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
