
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RPATH, or why lld doesn't work on NixOS</title>
  <meta name="description" content="I've learned a thing I wish I didn't know.
As a revenge, I am going to write it down so that you, my dear reader, also learn about this.
You probably want to skip this post unless you are interested and somewhat experienced in all of Rust, NixOS, and dynamic linking.">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://matklad.github.io/2022/03/14/rpath-or-why-lld-doesnt-work-on-nixos.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">matklad</a>
      <a href="/about.html">About</a>
      <a href="/resume.html">Resume</a>
      <a href="/links.html">Links</a>
    </nav>
  </header>

  <main>
  <article >

    <h1>
    <a href="#RPATH-or-why-lld-doesn-t-work-on-NixOS">RPATH, or why lld doesn&rsquo;t work on NixOS <time datetime="2022-03-14">Mar 14, 2022</time></a>
    </h1>
<p>I&rsquo;ve learned a thing I wish I didn&rsquo;t know.
As a revenge, I am going to write it down so that you, my dear reader, also learn about this.
You probably want to skip this post unless you are interested and somewhat experienced in all of Rust, NixOS, and dynamic linking.</p>
<section id="Problem">

    <h2>
    <a href="#Problem">Problem </a>
    </h2>
<p>I use NixOS and Rust.
For linking my Rust code, I would love to use lld, the LLVM linker, as it is significantly faster.
Unfortunately, this often leads to errors when trying to run the resulting binary:</p>

<figure class="code-block">


<pre><code>error while loading shared libraries: libbla.so.92:</code>
<code>cannot open shared object file: No such file or directory</code></pre>

</figure>
<p>Let&rsquo;s see what&rsquo;s going on here!</p>
</section>
<section id="Baseline">

    <h2>
    <a href="#Baseline">Baseline </a>
    </h2>
<p>We&rsquo;ll be using <code>evdev-rs</code> as a running example.
It is binding to the evdev shared library on Linux.
First, we&rsquo;ll build it with the default linker, which just works (haha, nope, this is NixOS).</p>
<p>Let&rsquo;s get the crate:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> git clone git@github.com:ndesh26/evdev-rs.git</code>
<code><span class="hl-title function_">$</span> cd evdev-rs</code></pre>

</figure>
<p>And run the example</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> cargo run --example evtest</code>
<code><span class="hl-output">    Updating crates.io index</span></code>
<code><span class="hl-output">  Downloaded libc v0.2.120</span></code>
<code><span class="hl-output">  Downloaded 1 crate (574.7 KB) in 1.10s</span></code>
<code><span class="hl-output">   Compiling cc v1.0.73</span></code>
<code><span class="hl-output">   Compiling pkg-config v0.3.24</span></code>
<code><span class="hl-output">   Compiling libc v0.2.120</span></code>
<code><span class="hl-output">   Compiling log v0.4.14</span></code>
<code><span class="hl-output">   Compiling cfg-if v1.0.0</span></code>
<code><span class="hl-output">   Compiling bitflags v1.3.2</span></code>
<code><span class="hl-output">   Compiling evdev-sys v0.2.4</span></code>
<code><span class="hl-output">error: failed to run custom build command for `evdev-sys`</span></code>
<code><span class="hl-output">&lt;---SNIP---&gt;</span></code>
<code><span class="hl-output">  Couldn't find libevdev from pkgconfig</span></code>
<code><span class="hl-output">&lt;---SNIP---&gt;</span></code></pre>

</figure>
<p>This of course doesn&rsquo;t just work and spits out humongous error message, which contains one line of important information: we are missing <code>libevdev</code> library.
As this is NixOS, we are not going to barbarically install it globally.
Let&rsquo;s create an isolated environment instead, using <code>nix-shell</code>:</p>

<figure class="code-block">
<figcaption class="title">shell.nix</figcaption>


<pre><code><span class="hl-keyword">with</span> <span class="hl-built_in">import</span> &lt;nixpkgs&gt; {};</code>
<code>mkShell {</code>
<code>    <span class="hl-attr">buildInputs</span> = [</code>
<code>        pkgconfig</code>
<code>        libevdev</code>
<code>    ];</code>
<code>}</code></pre>

</figure>
<p>And activate it:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> nix-shell</code></pre>

</figure>
<p>This environment gives us two things &mdash; the <code>pkg-config</code> binary and the <code>evdev</code> library.
<code>pkg-config</code> is a sort of half of a C package manager for UNIX: it can&rsquo;t install libraries, but it helps to locate them.
Let&rsquo;s ask it about <code>libevdev</code>:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> pkg-config --libs libevdev</code>
<code><span class="hl-output">-L/nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib -levdev</span></code></pre>

</figure>
<p>Essentially, it resolved library&rsquo;s short name (<code>libevdev</code>) to the full path to the directory were the library resides:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> exa -l /nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib</code>
<code><span class="hl-output">libevdev.la</span></code>
<code><span class="hl-output">libevdev.so -&gt; libevdev.so.2.3.0</span></code>
<code><span class="hl-output">libevdev.so.2 -&gt; libevdev.so.2.3.0</span></code>
<code><span class="hl-output">libevdev.so.2.3.0</span></code>
<code><span class="hl-output">pkgconfig</span></code></pre>

</figure>
<p>The <code>libevdev.so.2.3.0</code> file is the actual dynamic library.
The symlinks stuff is another bit of a C package manager which implements somewhat-semver: <code>libevdev.so.2</code> version requirement gets resolved to <code>libevdev.so.2.3.0</code> version.</p>
<p>Anyway, this works well enough to allow us to finally run the example</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> cargo run --example evtest</code>
<code><span class="hl-output">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span></code>
<code><span class="hl-output">     Running `target/debug/examples/evtest`</span></code>
<code><span class="hl-output">Usage: evtest /path/to/device</span></code></pre>

</figure>
<p>Success!</p>
<p>Ooook, so let&rsquo;s now do what we wanted to from the beginning and configure cargo to use <code>lld</code>, for blazingly fast linking.</p>
</section>
<section id="lld">

    <h2>
    <a href="#lld">lld </a>
    </h2>
<p>The magic spell you need need to put into <code>.cargo/config</code> is (courtesy of @lnicola):</p>

<figure class="code-block">


<pre><code><span class="hl-section">[build]</span></code>
<code><span class="hl-attr">rustflags</span> = [<span class="hl-string">&quot;-Clink-arg=-fuse-ld=lld&quot;</span>]</code></pre>

</figure>
<p>To unpack this:</p>
<ul>
<li>
<code>-C</code> set codegen option <code>link-arg=-fuse-ld=lld</code>.
</li>
<li>
<code>link-arg</code> means that <code>rustc</code> will pass &ldquo;-fuse-ld=lld&rdquo; to the linker.
</li>
<li>
Because linkers are not in the least confusing, the &ldquo;linker&rdquo; here is actually the whole gcc/clang.
That is, rather than invoking the linker, <code>rustc</code> will call <code>cc</code> and <em>that</em> will then call the linker.
</li>
<li>
So <code>-fuse-ld</code> (unlike <code>-C</code>, I <em>think</em> this is an atomic option, not <code>-f use-ld</code>) is an argument to gcc/clang,
which asks it to use <code>lld</code> linker.
</li>
<li>
And note that it&rsquo;s <code>lld</code> rather than <code>ldd</code> which confusingly exists and does something completely different.
</li>
</ul>
<p>Anyhow, the end result is that we switch the linker from <code>ld</code> (default slow GNU linker) to <code>lld</code> (fast LLVM linker).</p>
<p>And that breaks!</p>
<p><em>Building</em> the code still works fine:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> cargo build --example evtest</code>
<code><span class="hl-output">   Compiling libc v0.2.120</span></code>
<code><span class="hl-output">   Compiling pkg-config v0.3.24</span></code>
<code><span class="hl-output">   Compiling cc v1.0.73</span></code>
<code><span class="hl-output">   Compiling log v0.4.14</span></code>
<code><span class="hl-output">   Compiling cfg-if v1.0.0</span></code>
<code><span class="hl-output">   Compiling bitflags v1.3.2</span></code>
<code><span class="hl-output">   Compiling evdev-sys v0.2.4 (/home/matklad/tmp/evdev-rs/evdev-sys)</span></code>
<code><span class="hl-output">   Compiling evdev-rs v0.5.0 (/home/matklad/tmp/evdev-rs)</span></code>
<code><span class="hl-output">    Finished dev [unoptimized + debuginfo] target(s) in 2.87s</span></code></pre>

</figure>
<p>But <em>running</em> the binary fails:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> cargo run --example evtest</code>
<code><span class="hl-output">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span></code>
<code><span class="hl-output">     Running `target/debug/examples/evtest`</span></code>
<code><span class="hl-output">target/debug/examples/evtest: error while loading shared libraries:</span></code>
<code><span class="hl-output">libevdev.so.2: cannot open shared object file: No such file or directory</span></code></pre>

</figure>
</section>
<section id="rpath">

    <h2>
    <a href="#rpath">rpath </a>
    </h2>
<p>Ok, what&rsquo;s now?
Now, let&rsquo;s understand why the first example, with <code>ld</code> rather than <code>lld</code>, can&rsquo;t work :-)</p>
<p>As a reminder, we use NixOS, so there&rsquo;s no global folder a-la <code>/usr/lib</code> where all shared libraries are stored.
Coming back to our <code>pkgconfig</code> example,</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> pkg-config --libs libevdev</code>
<code><span class="hl-output">-L/nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib -levdev</span></code></pre>

</figure>
<p>the <code>libevdev.so</code> is well-hidden behind the hash.
So we need a <code>pkg-config</code> binary at compile time to get from <code>libevdev</code> name to actual location.</p>
<p>However, as this is a dynamic library, we need it not only during compilation, but during runtime as well.
And at runtime loader (also known as dynamic linker (its binary name is something like <code>ld-linux-x86-64.so</code>, but despite the <code>.so</code> suffix, it&rsquo;s an executable (I kid you not, this stuff is indeed this confusing))) loads the executable together with shared libraries required by it.
Normally, the loader looks for libraries in well-known locations, like the aforementioned <code>/usr/lib</code> or <code>LD_LIBRARY_PATH</code>.
So we need <em>something</em> which would tell the loader that <code>libevdev</code> lives at <code>/nix/store/$HASH/lib</code>.</p>
<p>That something is rpath (also known as RUNPATH) &ndash; this is more or less <code>LD_LIBRARY_PATH</code>, just hard-coded into the executable.
We can use <code>readelf</code> to inspect program&rsquo;s rpath.</p>
<p>When the binary is linked with the default linker, the result is as follows (lightly edited for clarity):</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> readelf -d target/debug/examples/evtest | rg PATH</code>
<code><span class="hl-output"> 0x000000000000001d (RUNPATH)            Library runpath: [</span></code>
<code><span class="hl-output">    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib64</span></code>
<code><span class="hl-output">    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib</span></code>
<code><span class="hl-output">    /nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib</span></code>
<code><span class="hl-output">    /nix/store/z56jcx3j1gfyk4sv7g8iaan0ssbdkhz1-glibc-2.33-56/lib</span></code>
<code><span class="hl-output">    /nix/store/c9f15p1kwm0mw5p13wsnvd1ixrhbhb12-gcc-10.3.0-lib/lib</span></code>
<code><span class="hl-output">]</span></code></pre>

</figure>
<p>And sure, we see path to <code>libevdev</code> right there!</p>
<p>With <code>rustflags = ["-Clink-arg=-fuse-ld=lld"]</code>, the result is different, the library is missing from rpath:</p>

<figure class="code-block">


<pre><code>0x000000000000001d (RUNPATH)            Library runpath: [</code>
<code>    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib64</code>
<code>    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib</code>
<code>]</code></pre>

</figure>
<p>At this point, I think we know what&rsquo;s going on.
To recap:</p>
<ul>
<li>
With both <code>ld</code> and <code>lld</code>, we don&rsquo;t have problems at compile time, because <code>pkg-config</code> helps the compiler to find the library.
</li>
<li>
At runtime, the library linked with <code>lld</code> fails to find the shared library, while the one linked with <code>ld</code> works.
</li>
<li>
The difference between the two binaries is the value of rpath in the binary itself.
<code>ld</code> somehow manages to include rpath which contains path to the library.
This rpath is what allows the loader to locate the library at runtime.
</li>
</ul>
<p>Curious observation: dynamic linking on NixOS is not <em>entirely</em> dynamic.
Because executables expect to find shared libraries in specific locations marked with hashes of the libraries themselves, it&rsquo;s not possible to <em>just</em> upgrade <code>.so</code> on disk for all the binaries to pick it up.</p>
</section>
<section id="Who-sets-rpath">

    <h2>
    <a href="#Who-sets-rpath">Who sets rpath? </a>
    </h2>
<p>At this point, we have only one question left:</p>
<p>Why?</p>
<p>Why do we have that magical rpath thing in one of the binaries.
The answer is simple &mdash; to set rpath, one passes <code>-rpath /nix/store/...</code> flag to the linker at compile time.
The linker then just embeds the specified string as rpath field in the executable, without really inspecting it in any way.</p>
<p>And here comes the magical/hacky bit &mdash; the thing that adds that <code>-rpath</code> argument to the linker&rsquo;s command line is the NixOS wrapper script!
That is, the <code>ld</code> on NixOS is not a proper ld, but rather a shell script which does a bit of extra fudging here and there, including the rpath:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> cat (which ld)</code>
<code><span class="hl-output">&lt;---SNIP---&gt;</span></code>
<code><span class="hl-output"></span></code>
<code><span class="hl-comment"># Three tasks:</span></code>
<code><span class="hl-comment">#</span></code>
<code><span class="hl-comment">#   1. Find all -L... switches for rpath</span></code>
<code><span class="hl-comment">#</span></code>
<code><span class="hl-comment">#   2. Find relocatable flag for build id.</span></code>
<code><span class="hl-comment">#</span></code>
<code><span class="hl-comment">#   3. Choose 32-bit dynamic linker if needed</span></code>
<code><span class="hl-output">declare -a libDirs</span></code>
<code><span class="hl-output">&lt;---SNIP---&gt;</span></code>
<code><span class="hl-output">        case "$prev" in</span></code>
<code><span class="hl-output">            -L)</span></code>
<code><span class="hl-output">                libDirs+=("$p")</span></code>
<code><span class="hl-output">                ;;</span></code>
<code><span class="hl-output">&lt;---SNIP---&gt;</span></code>
<code><span class="hl-output"></span></code>
<code><span class="hl-output">    for dir in ${libDirs+"${libDirs[@]}"}; do</span></code>
<code><span class="hl-output">        &lt;---SNIP---&gt;</span></code>
<code><span class="hl-output">                extraAfter+=(-rpath "$dir")</span></code>
<code><span class="hl-output">        &lt;---SNIP---&gt;</span></code>
<code><span class="hl-output">    done</span></code>
<code><span class="hl-output">&lt;---SNIP---&gt;</span></code>
<code><span class="hl-output">/nix/store/sga0l55gm9nlwglk79lmihwb2bpv597j-binutils-2.35.2/bin/ld \</span></code>
<code><span class="hl-output">    ${extraBefore+"${extraBefore[@]}"} \</span></code>
<code><span class="hl-output">    ${params+"${params[@]}"} \</span></code>
<code><span class="hl-output">    ${extraAfter+"${extraAfter[@]}"}</span></code></pre>

</figure>
<p>There&rsquo;s a lot of going on in that wrapper script, but the relevant thing to us, as far as I understand, is that everything that gets passed as <code>-L</code> at compile time gets embedded into the binary&rsquo;s rpath, so that it can be used at runtime as well.</p>
<p>Now, let&rsquo;s take a look at <code>lld</code>&rsquo;s wrapper:</p>

<figure class="code-block">


<pre><code><span class="hl-title function_">$</span> cat (which lld)</code>
<code><span class="hl-output">@@@@@@@TT@@pHpH&lt;&lt;E8o	8o	wN:HgPHwHpp@p@ @@  Stdpp@p@ Ptd@G@@QtdRtd/nix/store/4s21k8k7p1mfik0b33r2spq5hq7774k1-glibc-2.33-108/lib/ld-linux-x86-64.so.2GNUGNU r	\X</span></code>
<code><span class="hl-output">0F                                                                                                                                                                        &lt;C5`</span></code>
<code><span class="hl-output">Bx	rZ1V3	y</span></code></pre>

</figure>
<p>Haha, nope, there&rsquo;s no wrapper!
Unlike <code>ld</code>, <code>lld</code> on NixOS is an honest-to-Bosch binary file, and that&rsquo;s why we can&rsquo;t have great things!
This is tracked in issue #24744 in the nixpkgs repo :)</p>
<p>Update:</p>
<p>So&hellip;.. turns out there&rsquo;s more than one <code>lld</code> on NixOS.
There&rsquo;s <code>pkgs.lld</code>, the thing I have been using in the post.
And then there&rsquo;s <code>pkgs.llvmPackages.bintools</code> package, which also contains <code>lld</code>.
And that version is actually wrapped into an rpath-setting shell script, the same way <code>ld</code> is.</p>
<p>That is, <code>pkgs.lld</code> is the wrong <code>lld</code>, the right one is <code>pkgs.llvmPackages.bintools</code>.</p>
</section>
</article>
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/src/posts/2022-03-14-rpath-or-why-lld-doesnt-work-on-nixos.dj">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href="/feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
