
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Caches In Rust</title>
  <meta name="description" content="In this post I'll describe how to implement caches in Rust.
It is inspired by two recent refactors I landed at nearcore (nearcore#6549, nearcore#6811).
Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks spilling over, and spoiling the overall architecture of the application a bit.">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://matklad.github.io/2022/06/11/caches-in-rust.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">matklad</a>
      <a href="/about.html">About</a>
      <a href="/resume.html">Resume</a>
      <a href="/links.html">Links</a>
    </nav>
  </header>

  <main>
  <article >

    <h1>
    <a href="#Caches-In-Rust">Caches In Rust <time datetime="2022-06-11">Jun 11, 2022</time></a>
    </h1>
<p>In this post I&rsquo;ll describe how to implement caches in Rust.
It is inspired by two recent refactors I landed at nearcore (<a href="https://github.com/near/nearcore/pull/6549">nearcore#6549</a>, <a href="https://github.com/near/nearcore/pull/6811">nearcore#6811</a>).
Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks &ldquo;spilling over&rdquo;, and spoiling the overall architecture of the application a bit.</p>
<p>Let&rsquo;s start with an imaginary setup with an application with some configuration and a database:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>}</code></pre>

</figure>
<p>The database is an untyped key-value store:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">impl</span> <span class="hl-title class_">Db</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">load</span>(&amp;<span class="hl-keyword">self</span>, key: &amp;[<span class="hl-type">u8</span>]) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;<span class="hl-type">Vec</span>&lt;<span class="hl-type">u8</span>&gt;&gt;&gt; {</code>
<code>    ...</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>And the <code>App</code> encapsulates database and provides typed access to domain-specific <code>Widget</code>:</p>

<figure class="code-block">


<pre><code><span class="hl-meta">#[derive(serde::Serialize, serde::Deserialize)]</span></code>
<code><span class="hl-keyword">struct</span> <span class="hl-title class_">Widget</span> {</code>
<code>  title: <span class="hl-type">String</span>,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code>    &amp;<span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code>  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;Widget&gt;&gt; {</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>Now, for the sake of argument let&rsquo;s assume that database access and subsequent deserialization are costly, and that we want to add a cache of Widgets in front of the database.
Data-oriented thinking would compel us to get rid of deserialization step instead, but we will not pursue that idea this time.</p>
<p>We&rsquo;ll use a simple <code>HashMap</code> for the cache:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>  cache: HashMap&lt;<span class="hl-type">u32</span>, Widget&gt;,</code>
<code>}</code></pre>

</figure>
<p>And we need to modify <code>get_widget</code> method to return the value from the cache, if there is one:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code class="hl-line">    &amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code class="hl-line">  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;&amp;Widget&gt;&gt; {</code>
<code></code>
<code class="hl-line">    <span class="hl-keyword">if</span> <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">contains_key</span>(&amp;id) {</code>
<code class="hl-line">      <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get</span>(&amp;id).<span class="hl-title function_ invoke__">unwrap</span>();</code>
<code class="hl-line">      <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget));</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code class="hl-line">    <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">insert</span>(id, widget);</code>
<code class="hl-line">    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get</span>(&amp;id).<span class="hl-title function_ invoke__">unwrap</span>();</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>The biggest change is the <code>&amp;mut self</code>.
Even when reading the widget, we need to modify the <code>cache</code>, and the easiest way to get that ability is to require an exclusive reference.</p>
<p>I want to argue that this path of least resistance doesn&rsquo;t lead to a good place.
There are <em>many</em> problems with methods of the following-shape:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;Widget</code></pre>

</figure>
<p><em>First</em>, such methods conflict with each other.
For example, the following code won&rsquo;t work, because we&rsquo;ll try to borrow the app exclusively twice.</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">let</span> <span class="hl-variable">app</span>: &amp;<span class="hl-keyword">mut</span> App = ...;</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">w1</span> = app.<span class="hl-title function_ invoke__">get_widget</span>(<span class="hl-number">1</span>)?;</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">w2</span> = app.<span class="hl-title function_ invoke__">get_widget</span>(<span class="hl-number">2</span>)?;</code></pre>

</figure>
<p><em>Second</em>, the <code>&amp;mut</code> methods conflict even with <code>&amp;</code> methods.
Naively, it would seem that, as <code>get_widget</code> <em>returns</em> a shared reference, we should be able to call <code>&amp;</code> methods.
So, one can expect something like this to work:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">let</span> <span class="hl-variable">w</span>: &amp;Widget = app.<span class="hl-title function_ invoke__">get_widget</span>(<span class="hl-number">1</span>)?.<span class="hl-title function_ invoke__">unwrap</span>();</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">c</span>: &amp;Color = &amp;app.config.main_color;</code></pre>

</figure>
<p>Alas, it doesn&rsquo;t.
Rust borrow checker doesn&rsquo;t distinguish between <code>mut</code> and non-<code>mut</code> lifetimes (for a good reason: doing that would be unsound).
So, although <code>w</code> is just <code>&amp;Widget</code>, the lifetime there is the same as on the <code>&amp;mut self</code>, so the app remains mutably borrowed while the widget exists.</p>
<p><em>Third</em>, perhaps the most important point, the <code>&amp;mut self</code> becomes viral &mdash; most of functions in the program begin requiring <code>&amp;mut</code>, and you lose type-system distinction between read-only and read-write operations.
There&rsquo;s no distinction between &ldquo;this function can only modify the cache&rdquo; and &ldquo;this function can modify literally everything&rdquo;.</p>
<p><em>Finally</em>, even implementing <code>get_widget</code> is not pleasant.
Seasoned rustaceans among you might twitch at the needlessly-repeated hashmap lookups.
But trying to get rid of those with the help of the entry-API runs into current borrow checker limitations.</p>
<p>Let&rsquo;s look at how we can better tackle this!</p>
<p>The general idea for this class of problems is to think what the ownership and borrowing situation <em>should</em> be and try to achieve that, as opposed to merely following suggestions by the compiler.
That is, <em>most</em> of the time just using <code>&amp;mut</code> and <code>&amp;</code> as compiler guides you is a path to success, as, it turns out, majority of the code naturally follows simple aliasing rules.
But there are exceptions, it&rsquo;s important to recognize them as such and make use of interior mutability to implement the aliasing structure which makes sense.</p>
<p>Let&rsquo;s start with a simplified case.
Suppose that there&rsquo;s only one <code>Widget</code> to deal with.
In this case, we&rsquo;d want something like this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  ...</code>
<code>  cache: <span class="hl-type">Option</span>&lt;Widget&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;Widget {</code>
<code>    <span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(widget) = &amp;<span class="hl-keyword">self</span>.cache {</code>
<code>      <span class="hl-keyword">return</span> widget;</code>
<code>    }</code>
<code class="hl-line">    <span class="hl-keyword">self</span>.cache = <span class="hl-title function_ invoke__">Some</span>(<span class="hl-title function_ invoke__">create_widget</span>());</code>
<code>    <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">as_ref</span>().<span class="hl-title function_ invoke__">unwrap</span>()</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>This doesn&rsquo;t work as is &mdash; modifying the <code>cache</code> needs <code>&amp;mut</code> which we&rsquo;d very much prefer to avoid.
However, thinking about this pattern, it feels like it <em>should</em> be valid &mdash; we enforce at runtime that the contents of the <code>cache</code> is never overwritten.
That is, we actually <em>do</em> have exclusive access to cache on the highlighted line at runtime, we just can&rsquo;t explain that to the type system.
But we can reach out for <code>unsafe</code> for that.
What&rsquo;s more, Rust&rsquo;s type system is powerful enough to encapsulate that usage of unsafe into a safe and generally re-usable API.
So let&rsquo;s pull <a href="https://docs.rs/once_cell"><code>once_cell</code></a> crate for this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  ...</code>
<code>  cache: once_cell::sync::OnceCell&lt;Widget&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;Widget {</code>
<code>    <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get_or_init</span>(create_widget)</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>Coming back to the original hash-map example, we can apply the same logic here:
as long as we never overwrite, delete or move values, we can safely return references to them.
This is handled by the <a href="https://docs.rs/elsa"><code>elsa</code></a> crate:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>  cache: elsa::map::FrozenMap&lt;<span class="hl-type">u32</span>, <span class="hl-type">Box</span>&lt;Widget&gt;&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code>    &amp;<span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code>  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;&amp;Widget&gt;&gt; {</code>
<code>    <span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(widget) = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get</span>(&amp;id) {</code>
<code>      <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget));</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">insert</span>(id, <span class="hl-type">Box</span>::<span class="hl-title function_ invoke__">new</span>(widget));</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>The third case is that of a bounded cache.
If you need to evict values, than the above reasoning does not apply.
If the user of a cache gets a <code>&amp;T</code>, and than the corresponding entry is evicted, the reference would dangle.
In this situations, we want the clients of the cache to co-own the value.
This is easily handled by an <code>Rc</code>:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>  cache: RefCell&lt;lru::LruCache&lt;<span class="hl-type">u32</span>, Rc&lt;Widget&gt;&gt;&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code>    &amp;<span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code>  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;Rc&lt;Widget&gt;&gt;&gt; {</code>
<code>    {</code>
<code>      <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">cache</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">borrow_mut</span>();</code>
<code>      <span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(widget) = cache.<span class="hl-title function_ invoke__">get</span>(&amp;id) {</code>
<code>        <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(Rc::<span class="hl-title function_ invoke__">clone</span>(widget)));</code>
<code>      }</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = Rc::<span class="hl-title function_ invoke__">new</span>(widget);</code>
<code>    {</code>
<code>      <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">cache</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">borrow_mut</span>();</code>
<code>      cache.<span class="hl-title function_ invoke__">put</span>(id, Rc::<span class="hl-title function_ invoke__">clone</span>(&amp;widget));</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>To sum up: when implementing a cache, the path of the least resistance is to come up with a signature like this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;T</code></pre>

</figure>
<p>This often leads to problems down the line.
It&rsquo;s usually better to employ some interior mutability and get either of these instead:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;T</code>
<code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> T</code></pre>

</figure>
<p>This is an instance of the more general effect: despite the &ldquo;mutability&rdquo; terminology, Rust references track not mutability, but aliasing.
Mutability and exclusive access are correlated, but not perfectly.
It&rsquo;s important to identify instances where you need to employ interior mutability, often they are architecturally interesting.</p>
<p>To learn more about relationships between aliasing and mutability, I recommend the following two posts:</p>
<dl>
<dt>Rust: A unique perspective</dt>
<dd>
<p><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html" class="url">https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</a></p>
</dd>
<dt>Accurate mental model for Rust’s reference types</dt>
<dd>
<p><a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html" class="url">https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html</a></p>
</dd>
</dl>
<p>Finally, the &ldquo;borrow checker&rdquo; limitation is explained (with much skill and humor, I should add), in this document:</p>
<dl>
<dt>Polonius the Crab</dt>
<dd>
<p><a href="https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/" class="url">https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/</a></p>
</dd>
</dl>
<p>That&rsquo;s all! Discussion on <a href="https://old.reddit.com/r/rust/comments/v9xsnb/blog_post_caches_in_rust/">/r/rust</a>.</p>
</article>
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/src/posts/2022-06-11-caches-in-rust.dj">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href="/feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
